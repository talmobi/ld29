<html>
<head>
	<title>Ludum Dare 29</title>
	<style type="text/css">
		body {
			background-color: #222;
			color: #EEE;
		}
	</style>

	<script type="text/javascript" src="http://code.createjs.com/createjs-2013.12.12.min.js"></script>
	<script type="text/javascript" src="stats.js"></script>

</head>
<body onload="init()">
	<h1>Ludum Dare 29</h1>


	<div id="container">
		<canvas id="myCanvas">

		</canvas>
	</div>


	<script type="text/javascript">
		var c = createjs;

		/**
			* STATS
			*/
		var stats = new Stats();
		stats.setMode(1);
		// Align top-left
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.left = '260px';
		stats.domElement.style.top = '10px';
		document.body.appendChild( stats.domElement );

		/**
			* Game variables
			*/
		var size = 384;
		var width = size;
		var height = width * 9 / 16;
		var scale = 2;
		var tileSize = 2;
		var gravity = .1;

		var tickCount = 0;

		var entities = [];
		var buffer = [];

		var stage;
		var fps = 30;

		var once = false;
		var mousePressed = false;

		var GLOBAL = {
		}


		/**
			*	Load assets
			*/
		// init an empty map array
		var map = (function() {
			var w = width / tileSize;
			var h = height / tileSize;
				var arr = new Array(w);
			for (var i = 0; i < w; i++) {
				arr[i] = new Array(h);
			}
			//console.log(arr);
			return arr;
		})();

		var sprSheet = {};
		var sprTiles = [];

		var init = function() {

			var manifest = [
				{src:"assets/level.png", id:"level"},
				{src:"assets/sheet.png", id:"sheet"},
				{src:"assets/tiles.png", id:"tiles"}
			];

			var loader = new c.LoadQueue(false);
			loader.loadManifest(manifest);

			loader.addEventListener("complete", function() {

				/**
					* load tiles sprites
					*/
				var data = {
					images: [loader.getResult("tiles")],
					frames: {width: tileSize, height: tileSize}
				}
				var tileSheet = new c.SpriteSheet(data);
				for (var i = 0; i < tileSheet._frames.length; i++) {
					var spr = new c.Sprite(tileSheet, i);
					//console.log(spr);
					sprTiles.push(spr);
				}

				/**
					*	load sprite sheet
					*/
				var data = {
					images: [loader.getResult("sheet")],
					frames: {width: 9, height: 9},
					animations: {
						stand: 0,
						walk: {
							frames: [1, 0, 2, 0],
							speed: 1/4
						},
						build: [11, 12],
						spawn: [3, 4],
						gunwalk: {
							frames: [21, 20, 22, 20]
						},
						gunwalkshot: {
							frames: [31, 30, 32, 30]
						},
						voidwalk: [40,41],
						squidwalk: [50,51],
						squidshoot: [52, 53],
						fishmissile: [60, 61],
						treespawn: [70, 79],
						tree: 79,
						treetrapspawn: [80, 84],
						treetrap: 84,
						blueguywalk: {
							frames: [90, 91, 92, 91]
						},
						blueguyshoot: [93,95]
					}
				}
				var spriteSheet = new c.SpriteSheet(data);

				sprSheet = {
					greenguy: new c.Sprite(spriteSheet, "walk")
				}

				/*
				sprSheet = {
					stand: new c.Sprite(spriteSheet, "stand"),
					walk: new c.Sprite(spriteSheet, "walk"),
					build: new c.Sprite(spriteSheet, "buildd"),
					spawn: new c.Sprite(spriteSheet, "spawn"),
					gunwalk: new c.Sprite(spriteSheet, "gunwalk"),
					gunwalkshot: new c.Sprite(spriteSheet, "gunwalkshot"),
					voidwalk: new c.Sprite(spriteSheet, "voidwalk"),
					squidwalk: new c.Sprite(spriteSheet, "squidwalk"),
					squidshoot: new c.Sprite(spriteSheet, "squidshoot"),
					fishmissile: new c.Sprite(spriteSheet, "fishmissile"),
					treespawn: new c.Sprite(spriteSheet, "treespawn"),
					tree: new c.Sprite(spriteSheet, "tree"),
					treetrapspawn: new c.Sprite(spriteSheet, "treetrapspawn"),
					treetrap: new c.Sprite(spriteSheet, "treetrap"),
					blueguywalk: new c.Sprite(spriteSheet, "blueguywalk"),
					blueguyshoot: new c.Sprite(spriteSheet, "blueguyshoot"),
				}
				*/

				/**
					* load level data
					* To get the pixel data we need to first
					*	draw the image into a canvas and grab the
					*	imageData (pixels) from the canvas.
					*/
				var imgCanvas = document.createElement('canvas');
				imgCanvas.width = Math.floor(width / 2);
				imgCanvas.height = Math.floor(height / 2);
				var ctx = imgCanvas.getContext('2d');
				var img = loader.getResult("level");

				img.width = imgCanvas.width;
				img.height = imgCanvas.height;

				console.log(img);

				ctx.drawImage(loader.getResult("level"), 0, 0, img.width, img.height);
				document.body.appendChild(imgCanvas); // delete this
				// grab image data from the imgCanvas
				var imgData = ctx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
				var pixels = imgData.data;

				// loop through the pixels 4BYTE_RGBA
				var count = 0;
				for (var i = 0; i < pixels.length; i += 4) {
					// care only about alpha atm
					var a = pixels[i+3];
					if (a === 0) {
						// skip it
					} else {
						var x = Math.floor(count % imgCanvas.width);
						var y = Math.floor(count / imgCanvas.width);

						var tile;
						if (pixels[i+2] === 255) // blue
							tile = newTile(x * tileSize, y * tileSize, 'water');
							else
							tile = newTile(x * tileSize, y * tileSize);
						map[x][y] = tile;
					}

					count++;
				}

				console.log("count: " + count);

				/**
					* And finally start the game
					*/
				main();
			});
		}


		/**
			*	main
			*/

		var main = function() {
			var canvas = document.getElementById('myCanvas');

			canvas.width = width * scale;
			canvas.height = height * scale;

			/*
			var ctx = canvas.getContext('2d');
			ctx.scale(4,4);
			*/

			stage = new c.Stage(canvas);

			// between pixel fix
			stage.regX = .5;
			stage.regY = .5;

			// scale the stage
			stage.scaleX *= scale;
			stage.scaleY *= scale;

			stage.update();

			/**
				* Initialize Map
				*/
				console.log("w: " + map.length + ", h: " + map[0].length);
			var mapContainer = new c.Container();
			for (var i = 0; i < map.length; i++) {
				for (var j = 0; j < map[0].length; j++) {
					var t = map[i][j];
					if (!t)
						continue; // skip empty tiles
					mapContainer.addChild(t);
				}
			}
			// cache the map (draw time reduced dramatically)
			mapContainer.cache(0, 0, width, height);

			stage.addChild(mapContainer);

			/**
				*	add test objects
				*/
			for (var i = 0; i < 180; i++) {
				var entity = newEntity(20 + 2 * i, 100);
				buffer.push(entity);
				stage.addChild(entity);
			}
			for (var i = 0; i < 180; i++) {
				var entity = newEntity(19 + 2 * i, 120);
				buffer.push(entity);
				stage.addChild(entity);
			}


			// add tiles when mouse is pressed
			stage.addEventListener('stagemousemove', function(evt) {
				if (mousePressed) {
					var x = Math.floor(evt.stageX / scale);
					var y = Math.floor(evt.stageY / scale);
					if (x < 0 || x >= width || y < 0 || y >= height)
						return;
					var i = Math.floor(x / tileSize);
					var j = Math.floor(y / tileSize);
					//alert("x: " + x + ", y: " + y);
					if (!map[i][j]) {
						console.log("SDKF");
						var t = newTile(x,y);
						map[i][j] = t;
						stage.addChild(t);
					}
				}
			});

			stage.addEventListener('stagemousedown', function(evt) {
				mousePressed = true;
			});

			stage.addEventListener('stagemouseup', function(evt) {
				mousePressed = false;
			});


			/**
				* add a border and update stage
				*/
			var border = newBox(1, 1, width - 1, height - 1);
			stage.addChild(border);

			stage.update();

			/**
				* configure Ticker
				*/
			c.Ticker.addEventListener('tick', tick);
			c.Ticker.setFPS(fps);
		}

		/**
			* Game objects creators
			*/
		var newTile = function(x, y, type) {
			var n = 0;
			if (type === 'water') {
				n = 4;
			}
			var spr = sprTiles[n].clone();
			spr.type = type || 'ground';
			spr.exists = true;
			spr.snapToPixel = true;
			spr.x = x;
			spr.y = y;
			spr.w = tileSize;
			spr.h = tileSize;
			return spr;
		}

		/**
			* Entity
			*/
		var newEntity = function(x, y) {
			var self = sprSheet.greenguy.clone();
			self.snapToPixel = true;
			self.removed = false;
			self.x = x;
			self.y = y;
			self.w = 9;
			self.h = 9;

			/*self.filters = [
				new createjs.ColorFilter(Math.random(), Math.random(), Math.random(), 1, 200, 0, 0, 0)
			];*/

			self.yspeed = 0;
			self.xspeed = 0;

			self.onFloor = false;

			self.lastyspeed = 0;

			self.tick = function() {
				if (this.lastyspeed < 0 && this.yspeed >= 0 && !this.onFloor) {
					this.scaleX *= -1;
					if (this.scaleX < 0)
						this.regX = 9;
					else
						this.regX = 0;
				}
				this.lastyspeed = this.yspeed;

				if (!this.onFloor) {
					var i = Math.floor( (this.x + 4) / tileSize );
					var j = Math.floor( (this.y + this.h + this.yspeed)  / tileSize );
					var t = map[i][j];
					//if (!t) return;
					if (!t || this.yspeed < 0) {
						this.yspeed += gravity;
						if (this.currentAnimation !== 'walk')
							this.gotoAndPlay("walk");
					} else {

						switch (t.type) {
							case 'water':
								if (Math.abs(this.yspeed) > 1)
									this.yspeed *= 0.85;
								if (Math.abs(this.yspeed) > 0.2)
									this.yspeed *= 0.95;
								if (Math.abs(this.yspeed < .15))
									this.yspeed = Math.sign(this.yspeed) * 0.15;
								break;
							case 'ground':
								if (map[i][j - 1] &&  map[i][j - 1].type === 'ground')
									t = map[i][j - 1];
								this.onFloor = true;
								this.yspeed = 0;
								this.y = t.y - this.h;
								this.gotoAndStop("stand");
								//console.log("collision");


								/*if (!once) {
									once = true;
									console.log("Entity: x - " + this.x + ", y - " + this.y);
									console.log("Tile: x - " + t.x + ", y - " + t.y);
									console.log("Check: i - " + i + ", j - " + j);
								}*/
								var that = this;
								var j = function() {
									that.jump(Math.random() * 5);
								};

								setTimeout(function() {
									j();
								}, Math.random() * 5 * 250);
								//j();

								break;
						}
					}

					this.y += this.yspeed;
					this.x += this.xspeed;		
				}

				self.jump = function(amount) {
					if (this.onFloor) {
						this.onFloor = false;
						this.yspeed = -amount;
					}
				}
			}

			return self;
		}


		/**
			*	Shape creators
			*/
		var newBox = function(x,y,w,h) {
			var box = new c.Shape();
			box.snapToPixel = true;
			box.graphics.setStrokeStyle(1).beginStroke("white").rect(x, y, w, h);
			return box;
		}


		/**
			*	tick
			*/
		var tick = function() {
			tickCount++;
			stats.begin();

			for (var i = 0; i < entities.length; i++) {
				var e = entities[i];
				if (!e.removed) {
					e.tick();
					buffer.push(e);
				}
			}

			// swap
			var t = entities;
			entities = buffer;
			buffer = t;
			//buffer.length = 0; // supposedly third fastest
			while (buffer.length > 0) // supposedly second fastest
				buffer.pop();
			//buffer = []; // suppposedly to be fastest
			// src: http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript

			stage.update();

			stats.end();
		}

	</script>

</body>
</html>